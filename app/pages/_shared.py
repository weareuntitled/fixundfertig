# Auto generated by scripts/split_pages.py
# Shared imports, constants and helpers from the former pages.py

# FixundFertig/app/pages.py

from __future__ import annotations

import os
import base64
import json
import time
from datetime import datetime, timedelta
from urllib.parse import urlencode

from nicegui import ui, app
from sqlmodel import select
from sqlalchemy import literal, case, union_all, func

from data import (
    Company,
    Customer,
    Invoice,
    InvoiceItem,
    InvoiceItemTemplate,
    Expense,
    InvoiceRevision,
    log_audit_action,
    InvoiceStatus,
    get_session,
)

from renderer import render_invoice_to_pdf_bytes
from actions import cancel_invoice, create_correction, delete_draft, update_status_logic

from styles import (
    C_CARD,
    C_CARD_HOVER,
    C_BTN_PRIM,
    C_BTN_SEC,
    C_INPUT,
    C_PAGE_TITLE,
    C_SECTION_TITLE,
    C_TABLE_HEADER,
    C_TABLE_ROW,
    C_BADGE_GREEN,
    C_CONTAINER,
)

from ui_components import (
    format_invoice_status,
    invoice_status_badge,
    kpi_card,
    sticky_header,
)

from logic import (
    finalize_invoice_logic,
    export_invoices_pdf_zip,
    export_invoices_csv,
    export_invoice_items_csv,
    export_customers_csv,
    export_database_backup,
)


# -------------------------
# Helpers
# -------------------------

def log_invoice_action(action: str, invoice_id: int | None = None) -> None:
    with get_session() as s:
        log_audit_action(s, action, invoice_id=invoice_id)
        s.commit()


def _parse_iso_date(value: str | None):
    try:
        return datetime.fromisoformat(value or "")
    except Exception:
        return datetime.min


def _open_invoice_detail(invoice_id: int) -> None:
    app.storage.user["invoice_detail_id"] = int(invoice_id)
    app.storage.user["page"] = "invoice_detail"
    ui.navigate.to("/")


def _open_invoice_editor(draft_id: int | None) -> None:
    app.storage.user["invoice_draft_id"] = int(draft_id) if draft_id else None
    app.storage.user["page"] = "invoice_create"
    ui.navigate.to("/")


def render_logo_card() -> None:
    with ui.card().classes(C_CARD + " p-5 w-full"):
        ui.label("Logo").classes(C_SECTION_TITLE)
        ui.label("Quadratisches PNG oder JPG empfohlen.").classes("text-sm text-slate-500 mb-2")

        def on_up(e):
            os.makedirs("./storage", exist_ok=True)
            with open("./storage/logo.png", "wb") as f:
                f.write(e.content.read())
            ui.notify("Hochgeladen", color="green")

        ui.upload(on_upload=on_up, auto_upload=True, label="Bild wählen").props("flat dense").classes("w-full")


def render_contact_card(comp: Company):
    with ui.card().classes(C_CARD + " p-5 w-full"):
        ui.label("Kontakt").classes(C_SECTION_TITLE)
        first_name = ui.input("Vorname", value=comp.first_name).classes(C_INPUT)
        last_name = ui.input("Nachname", value=comp.last_name).classes(C_INPUT)
        email = ui.input("Email", value=comp.email).classes(C_INPUT)
        phone = ui.input("Telefon", value=comp.phone).classes(C_INPUT)
    return {
        "first_name": first_name,
        "last_name": last_name,
        "email": email,
        "phone": phone,
    }


def render_address_card(comp: Company):
    with ui.card().classes(C_CARD + " p-5 w-full"):
        ui.label("Adresse").classes(C_SECTION_TITLE)
        street = ui.input("Straße", value=comp.street).classes(C_INPUT)
        postal_code = ui.input("PLZ", value=comp.postal_code).classes(C_INPUT)
        city = ui.input("Ort", value=comp.city).classes(C_INPUT)
    return {
        "street": street,
        "postal_code": postal_code,
        "city": city,
    }


def render_business_meta_card(comp: Company):
    with ui.card().classes(C_CARD + " p-5 w-full"):
        ui.label("Firma").classes(C_SECTION_TITLE)
        name = ui.input("Firma", value=comp.name).classes(C_INPUT)
        iban = ui.input("IBAN", value=comp.iban).classes(C_INPUT)
        tax = ui.input("Steuernummer", value=comp.tax_id).classes(C_INPUT)
        vat = ui.input("USt-ID", value=comp.vat_id).classes(C_INPUT)
    return {
        "name": name,
        "iban": iban,
        "tax_id": tax,
        "vat_id": vat,
    }


def render_integrations_card() -> None:
    with ui.card().classes(C_CARD + " p-5 w-full"):
        ui.label("Integrationen").classes(C_SECTION_TITLE)
        ui.label("Noch keine Integrationen verbunden.").classes("text-sm text-slate-500")


# -------------------------
# PDF Download and Mail
# -------------------------

def download_invoice_file(invoice: Invoice) -> None:
    if invoice and invoice.id:
        log_invoice_action("EXPORT_CREATED", invoice.id)

    pdf_path = invoice.pdf_filename

    # If we have no file yet, create one
    if not pdf_path:
        pdf_bytes = render_invoice_to_pdf_bytes(invoice)
        if isinstance(pdf_bytes, bytearray):
            pdf_bytes = bytes(pdf_bytes)
        if not isinstance(pdf_bytes, bytes):
            raise TypeError("PDF output must be bytes")

        filename = f"rechnung_{invoice.nr}.pdf" if invoice.nr else "rechnung.pdf"
        pdf_path = f"storage/invoices/{filename}"
        os.makedirs(os.path.dirname(pdf_path), exist_ok=True)
        with open(pdf_path, "wb") as f:
            f.write(pdf_bytes)

        invoice.pdf_filename = filename
        invoice.pdf_storage = "local"

        if invoice.id:
            with get_session() as s:
                inv = s.get(Invoice, invoice.id)
                if inv:
                    inv.pdf_filename = filename
                    inv.pdf_storage = "local"
                    s.add(inv)
                    s.commit()

        ui.download(pdf_path)
        return

    # Normalized path
    if not os.path.isabs(pdf_path) and not str(pdf_path).startswith("storage/"):
        pdf_path = f"storage/invoices/{pdf_path}"

    if os.path.exists(pdf_path):
        ui.download(pdf_path)
        return

    # File missing but invoice exists, regenerate
    pdf_bytes = render_invoice_to_pdf_bytes(invoice)
    if isinstance(pdf_bytes, bytearray):
        pdf_bytes = bytes(pdf_bytes)
    if not isinstance(pdf_bytes, bytes):
        raise TypeError("PDF output must be bytes")

    filename = os.path.basename(invoice.pdf_filename) if invoice.pdf_filename else (f"rechnung_{invoice.nr}.pdf" if invoice.nr else "rechnung.pdf")
    pdf_path = f"storage/invoices/{filename}"
    os.makedirs(os.path.dirname(pdf_path), exist_ok=True)
    with open(pdf_path, "wb") as f:
        f.write(pdf_bytes)

    invoice.pdf_filename = filename
    invoice.pdf_storage = "local"

    if invoice.id:
        with get_session() as s:
            inv = s.get(Invoice, invoice.id)
            if inv:
                inv.pdf_filename = filename
                inv.pdf_storage = "local"
                s.add(inv)
                s.commit()

    ui.download(pdf_path)


def build_invoice_mailto(comp: Company | None, customer: Customer | None, invoice: Invoice) -> str:
    subject = f"Rechnung {invoice.nr or ''}".strip()
    amount = f"{float(invoice.total_brutto or 0):,.2f} EUR"

    body_lines = [
        f"Guten Tag {customer.display_name if customer else ''},".strip(),
        "",
        f"im Anhang finden Sie Ihre Rechnung {invoice.nr or ''} vom {invoice.date} über {amount}.",
        "",
        "Viele Grüße",
        comp.name if comp else "",
    ]

    params = urlencode({
        "subject": subject,
        "body": "\n".join(line for line in body_lines if line is not None),
    })

    recipient = customer.email if customer and customer.email else ""
    return f"mailto:{recipient}?{params}"


def send_invoice_email(comp: Company | None, customer: Customer | None, invoice: Invoice) -> None:
    if not customer or not customer.email:
        ui.notify("Keine Email-Adresse beim Kunden hinterlegt", color="red")
        return
    mailto = build_invoice_mailto(comp, customer, invoice)
    ui.run_javascript(f"window.location.href = {json.dumps(mailto)}")


# -------------------------
# Revisions "Edit with risk"
# -------------------------

def _snapshot_invoice(session, invoice: Invoice) -> str:
    items = session.exec(select(InvoiceItem).where(InvoiceItem.invoice_id == invoice.id)).all()
    payload = {
        "invoice": {
            "id": invoice.id,
            "customer_id": invoice.customer_id,
            "nr": invoice.nr,
            "title": invoice.title,
            "date": invoice.date,
            "delivery_date": invoice.delivery_date,
            "recipient_name": invoice.recipient_name,
            "recipient_street": invoice.recipient_street,
            "recipient_postal_code": invoice.recipient_postal_code,
            "recipient_city": invoice.recipient_city,
            "total_brutto": invoice.total_brutto,
            "status": invoice.status.value if hasattr(invoice.status, "value") else str(invoice.status),
            "revision_nr": invoice.revision_nr,
            "updated_at": invoice.updated_at,
            "related_invoice_id": invoice.related_invoice_id,
            "pdf_filename": invoice.pdf_filename,
            "pdf_storage": invoice.pdf_storage,
        },
        "items": [
            {
                "id": it.id,
                "description": it.description,
                "quantity": it.quantity,
                "unit_price": it.unit_price,
            }
            for it in items
        ],
    }
    return json.dumps(payload)


def create_invoice_revision_and_edit(invoice_id: int, reason: str) -> int | None:
    with get_session() as s:
        original = s.get(Invoice, invoice_id)
        if not original:
            return None

        next_revision = int(original.revision_nr or 0) + 1
        snapshot_json = _snapshot_invoice(s, original)

        s.add(InvoiceRevision(
            invoice_id=original.id,
            revision_nr=next_revision,
            reason=reason,
            snapshot_json=snapshot_json,
            pdf_filename_previous=original.pdf_filename or "",
        ))

        original.revision_nr = next_revision
        original.updated_at = datetime.now().isoformat()
        s.add(original)

        new_inv = Invoice(
            customer_id=original.customer_id,
            nr=None,
            title=original.title,
            date=original.date,
            delivery_date=original.delivery_date,
            recipient_name=original.recipient_name,
            recipient_street=original.recipient_street,
            recipient_postal_code=original.recipient_postal_code,
            recipient_city=original.recipient_city,
            total_brutto=original.total_brutto,
            status=InvoiceStatus.DRAFT,
            related_invoice_id=original.id,
        )
        s.add(new_inv)
        s.commit()
        s.refresh(new_inv)

        old_items = s.exec(select(InvoiceItem).where(InvoiceItem.invoice_id == original.id)).all()
        for it in old_items:
            s.add(InvoiceItem(
                invoice_id=new_inv.id,
                description=it.description,
                quantity=it.quantity,
                unit_price=it.unit_price,
            ))

        log_audit_action(s, "INVOICE_RISK_EDIT", invoice_id=original.id)
        s.commit()

        return int(new_inv.id)


# -------------------------
# Dashboard
# -------------------------



# -------------------------
# Invoice Editor
# -------------------------



# -------------------------
# Invoice Detail
# -------------------------

def _status_step_current(invoice: Invoice) -> InvoiceStatus:
    s = invoice.status
    if s == InvoiceStatus.DRAFT:
        return InvoiceStatus.DRAFT
    if s in (InvoiceStatus.OPEN, InvoiceStatus.FINALIZED):
        return InvoiceStatus.OPEN
    if s == InvoiceStatus.SENT:
        return InvoiceStatus.SENT
    if s == InvoiceStatus.PAID:
        return InvoiceStatus.PAID
    if s == InvoiceStatus.CANCELLED:
        return InvoiceStatus.CANCELLED
    return InvoiceStatus.OPEN


def _render_status_stepper(invoice: Invoice) -> None:
    current = _status_step_current(invoice)
    steps = [
        (InvoiceStatus.DRAFT, "Entwurf"),
        (InvoiceStatus.OPEN, "Finalisiert"),
        (InvoiceStatus.SENT, "Gesendet"),
        (InvoiceStatus.PAID, "Bezahlt"),
        (InvoiceStatus.CANCELLED, "Storniert"),
    ]
    with ui.row().classes("items-center gap-2 flex-wrap"):
        for idx, (key, label) in enumerate(steps):
            is_active = key == current
            cls = "text-slate-900 font-semibold text-sm" if is_active else "text-slate-400 text-sm"
            ui.label(label).classes(cls)
            if idx < len(steps) - 1:
                ui.label("→").classes("text-slate-300 text-sm")




# -------------------------
# Invoices List (70/30)
# -------------------------



# -------------------------
# Customers
# -------------------------







# -------------------------
# Exports
# -------------------------



# -------------------------
# Settings
# -------------------------



# -------------------------
# Ledger (Finanzen)
# -------------------------



# -------------------------
# Expenses
# -------------------------
