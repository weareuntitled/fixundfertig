# Auto generated by scripts/split_pages.py
# Shared imports, constants and helpers from the former pages.py

# FixundFertig/app/pages.py

from __future__ import annotations

import os
import base64
import json
import time
import logging
import functools
import inspect
from datetime import datetime, timedelta
from urllib.parse import urlencode
from urllib.request import Request, urlopen

from nicegui import ui, app
from sqlmodel import select
from sqlalchemy import literal, case, union_all, func

from data import (
    Company,
    Customer,
    Invoice,
    InvoiceItem,
    InvoiceItemTemplate,
    Expense,
    InvoiceRevision,
    Document,
    log_audit_action,
    InvoiceStatus,
    get_session,
    User,
)

from renderer import render_invoice_to_pdf_bytes
from actions import cancel_invoice, create_correction, delete_draft, update_status_logic
from invoice_numbering import build_invoice_filename

from styles import (
    C_CARD,
    C_CARD_HOVER,
    C_GLASS_CARD_HOVER,
    C_BTN_PRIM,
    C_BTN_SEC,
    C_INPUT,
    C_PAGE_TITLE,
    C_SECTION_TITLE,
    C_TABLE_HEADER,
    C_TABLE_ROW,
    C_BADGE_GREEN,
    C_CONTAINER,
    C_GLASS_CARD,
)

from ui_components import (
    format_invoice_status,
    invoice_status_badge,
    kpi_card,
    settings_card,
    settings_grid,
    settings_two_column_layout,
    sticky_header,
)

from logic import (
    finalize_invoice_logic,
    export_invoices_pdf_zip,
    export_invoices_csv,
    export_invoice_items_csv,
    export_customers_csv,
    export_database_backup,
)


# -------------------------
# Helpers
# -------------------------

logger = logging.getLogger(__name__)


def ui_handler(context: str, *, notify_message: str = "Aktion fehlgeschlagen.") -> callable:
    def decorator(func: callable) -> callable:
        if inspect.iscoroutinefunction(func):
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs):
                try:
                    return await func(*args, **kwargs)
                except Exception:
                    logger.exception("UI handler failed: %s", context, extra={"context": context})
                    ui.notify(notify_message, color="red")

            return async_wrapper

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception:
                logger.exception("UI handler failed: %s", context, extra={"context": context})
                ui.notify(notify_message, color="red")

        return wrapper

    return decorator

def get_current_user_id(session) -> int | None:
    identifier = app.storage.user.get("auth_user")
    if not identifier:
        return None
    statement = select(User).where((User.email == identifier) | (User.username == identifier))
    user = session.exec(statement).first()
    return user.id if user else None


def list_companies(session, user_id: int) -> list[Company]:
    statement = select(Company).where(Company.user_id == user_id).order_by(Company.id)
    return list(session.exec(statement))


def get_primary_company(session, user_id: int) -> Company:
    companies = list_companies(session, user_id)
    if companies:
        return companies[0]
    unassigned = session.exec(select(Company).where(Company.user_id.is_(None))).first()
    if unassigned:
        unassigned.user_id = user_id
        session.add(unassigned)
        session.commit()
        return unassigned
    company = Company(user_id=user_id)
    session.add(company)
    session.commit()
    return company

def log_invoice_action(action: str, invoice_id: int | None = None) -> None:
    with get_session() as s:
        log_audit_action(s, action, invoice_id=invoice_id)
        s.commit()


def _parse_iso_date(value: str | None):
    try:
        return datetime.fromisoformat(value or "")
    except Exception:
        return datetime.min


def _open_invoice_detail(invoice_id: int) -> None:
    app.storage.user["invoice_detail_id"] = int(invoice_id)
    app.storage.user["page"] = "invoice_detail"
    ui.navigate.to("/")


def _open_invoice_editor(draft_id: int | None) -> None:
    app.storage.user["invoice_draft_id"] = int(draft_id) if draft_id else None
    app.storage.user["page"] = "invoice_create"
    ui.navigate.to("/")


def _fetch_address_autocomplete(query: str, country_code: str) -> list[dict]:
    if len(query.strip()) < 3:
        return []
    base_url = os.environ.get("APP_BASE_URL", "http://localhost:8080")
    params = urlencode({"q": query, "country": country_code})
    url = f"{base_url}/api/address-autocomplete?{params}"
    request = Request(url, headers={"Accept": "application/json"})
    try:
        with urlopen(request, timeout=6) as response:
            payload = json.loads(response.read().decode("utf-8"))
    except Exception:
        return []
    if not isinstance(payload, list):
        return []
    return payload


def use_address_autocomplete(
    street_input: ui.input,
    zip_input: ui.input,
    city_input: ui.input,
    country_input: ui.input,
    dropdown_container: ui.element,
    *,
    country_code: str = "DE",
    debounce_seconds: float = 0.35,
) -> None:
    state = {
        "query": "",
        "results": [],
        "open": False,
        "active_index": -1,
        "pending": False,
        "last_change": 0.0,
    }

    def set_dropdown_visible(visible: bool) -> None:
        dropdown_container.style(f"display: {'block' if visible else 'none'}")

    set_dropdown_visible(False)

    def apply_result(result: dict) -> None:
        street_input.value = result.get("street") or ""
        zip_input.value = result.get("zip") or ""
        city_input.value = result.get("city") or ""
        country_value = result.get("country") or country_input.value or country_code
        country_input.value = country_value
        state["open"] = False
        state["active_index"] = -1
        set_dropdown_visible(False)

    def update_dropdown() -> None:
        dropdown_container.clear()
        if not state["open"] or not state["results"]:
            set_dropdown_visible(False)
            return

        set_dropdown_visible(True)
        for idx, result in enumerate(state["results"]):
            label = result.get("label") or ""
            is_active = idx == state["active_index"]
            option_classes = "w-full text-left px-3 py-2 text-sm hover:bg-slate-50"
            if is_active:
                option_classes += " bg-slate-100"
            with ui.element("button").props(
                f"type=button role=option aria-selected={'true' if is_active else 'false'}"
            ).classes(option_classes).on("click", lambda _, r=result: apply_result(r)):
                ui.label(label).classes("text-left text-slate-700")

    def on_input_change(_) -> None:
        state["query"] = street_input.value or ""
        state["pending"] = True
        state["last_change"] = time.monotonic()

    def on_keydown(e) -> None:
        key = (e.args or {}).get("key")
        if key == "ArrowDown":
            if state["results"]:
                state["open"] = True
                state["active_index"] = (state["active_index"] + 1) % len(state["results"])
                update_dropdown()
        elif key == "ArrowUp":
            if state["results"]:
                state["open"] = True
                state["active_index"] = (state["active_index"] - 1) % len(state["results"])
                update_dropdown()
        elif key == "Enter":
            if state["open"] and 0 <= state["active_index"] < len(state["results"]):
                apply_result(state["results"][state["active_index"]])
        elif key == "Escape":
            state["open"] = False
            state["active_index"] = -1
            set_dropdown_visible(False)

    def debounce_tick() -> None:
        if not state["pending"]:
            return
        if time.monotonic() - state["last_change"] < debounce_seconds:
            return
        state["pending"] = False
        query = state["query"].strip()
        if len(query) < 3:
            state["results"] = []
            state["open"] = False
            state["active_index"] = -1
            update_dropdown()
            return
        results = _fetch_address_autocomplete(query, country_code)
        state["results"] = results
        state["open"] = bool(results)
        state["active_index"] = 0 if results else -1
        update_dropdown()

    street_input.on("input", on_input_change)
    street_input.on("keydown", on_keydown)
    street_input.on("focus", lambda _: update_dropdown())
    ui.timer(0.1, debounce_tick)


def customer_contact_card(
    *,
    name_value: str = "",
    first_value: str = "",
    last_value: str = "",
    email_value: str = "",
    short_code_value: str = "",
    title: str = "Kontakt",
) -> dict[str, ui.input]:
    with settings_card(title):
        with settings_grid():
            name = ui.input("Firma", value=name_value).classes(C_INPUT)
            first = ui.input("Vorname", value=first_value).classes(C_INPUT)
            last = ui.input("Nachname", value=last_value).classes(C_INPUT)
            email = ui.input("Email", value=email_value).classes(C_INPUT)
            short_code = ui.input("Kürzel (optional)", value=short_code_value).classes(C_INPUT)

    return {
        "name": name,
        "first": first,
        "last": last,
        "email": email,
        "short_code": short_code,
    }


def customer_address_card(
    *,
    street_value: str = "",
    plz_value: str = "",
    city_value: str = "",
    country_value: str = "",
    country_fallback: str = "DE",
    title: str = "Adresse",
) -> dict[str, ui.input]:
    with settings_card(title):
        with settings_grid():
            with ui.element("div").classes("relative w-full"):
                street = ui.input("Straße", value=street_value).classes(C_INPUT)
                street_dropdown = ui.element("div").classes(
                    "absolute left-0 right-0 mt-1 z-10 bg-white border border-slate-200 rounded-lg shadow-sm"
                )
            plz = ui.input("PLZ", value=plz_value).classes(C_INPUT)
            city = ui.input("Ort", value=city_value).classes(C_INPUT)
            country = ui.input("Land", value=country_value or country_fallback).classes(C_INPUT)

    use_address_autocomplete(
        street,
        plz,
        city,
        country,
        street_dropdown,
    )

    return {
        "street": street,
        "plz": plz,
        "city": city,
        "country": country,
    }


def customer_business_meta_card(
    *,
    vat_value: str = "",
    title: str = "Business",
) -> dict[str, ui.input]:
    with settings_card(title):
        with settings_grid():
            vat = ui.input("USt-ID", value=vat_value).classes(C_INPUT)

    return {"vat": vat}


# -------------------------
# PDF Download and Mail
# -------------------------

def download_invoice_file(invoice: Invoice) -> None:
    if invoice and invoice.id:
        log_invoice_action("EXPORT_CREATED", invoice.id)

    pdf_path = invoice.pdf_filename

    # If we have no file yet, create one
    if not pdf_path:
        with get_session() as s:
            customer = s.get(Customer, int(invoice.customer_id)) if invoice.customer_id else None
            company = s.exec(select(Company)).first() or Company()
        pdf_bytes = render_invoice_to_pdf_bytes(invoice)
        if isinstance(pdf_bytes, bytearray):
            pdf_bytes = bytes(pdf_bytes)
        if not isinstance(pdf_bytes, bytes):
            raise TypeError("PDF output must be bytes")

        filename = build_invoice_filename(company, invoice, customer) if invoice.nr else "rechnung.pdf"
        pdf_path = f"storage/invoices/{filename}"
        os.makedirs(os.path.dirname(pdf_path), exist_ok=True)
        with open(pdf_path, "wb") as f:
            f.write(pdf_bytes)

        invoice.pdf_filename = filename
        invoice.pdf_storage = "local"

        if invoice.id:
            with get_session() as s:
                inv = s.get(Invoice, invoice.id)
                if inv:
                    inv.pdf_filename = filename
                    inv.pdf_storage = "local"
                    s.add(inv)
                    s.commit()

        ui.download(pdf_path)
        return

    # Normalized path
    if not os.path.isabs(pdf_path) and not str(pdf_path).startswith("storage/"):
        pdf_path = f"storage/invoices/{pdf_path}"

    if os.path.exists(pdf_path):
        ui.download(pdf_path)
        return

    # File missing but invoice exists, regenerate
    with get_session() as s:
        customer = s.get(Customer, int(invoice.customer_id)) if invoice.customer_id else None
        company = s.exec(select(Company)).first() or Company()
    pdf_bytes = render_invoice_to_pdf_bytes(invoice)
    if isinstance(pdf_bytes, bytearray):
        pdf_bytes = bytes(pdf_bytes)
    if not isinstance(pdf_bytes, bytes):
        raise TypeError("PDF output must be bytes")

    filename = os.path.basename(invoice.pdf_filename) if invoice.pdf_filename else (build_invoice_filename(company, invoice, customer) if invoice.nr else "rechnung.pdf")
    pdf_path = f"storage/invoices/{filename}"
    os.makedirs(os.path.dirname(pdf_path), exist_ok=True)
    with open(pdf_path, "wb") as f:
        f.write(pdf_bytes)

    invoice.pdf_filename = filename
    invoice.pdf_storage = "local"

    if invoice.id:
        with get_session() as s:
            inv = s.get(Invoice, invoice.id)
            if inv:
                inv.pdf_filename = filename
                inv.pdf_storage = "local"
                s.add(inv)
                s.commit()

    ui.download(pdf_path)


def build_invoice_mailto(comp: Company | None, customer: Customer | None, invoice: Invoice) -> str:
    subject = f"Rechnung {invoice.nr or ''}".strip()
    amount = f"{float(invoice.total_brutto or 0):,.2f} EUR"

    body_lines = [
        f"Guten Tag {customer.display_name if customer else ''},".strip(),
        "",
        f"im Anhang finden Sie Ihre Rechnung {invoice.nr or ''} vom {invoice.date} über {amount}.",
        "",
        "Viele Grüße",
        comp.name if comp else "",
    ]

    params = urlencode({
        "subject": subject,
        "body": "\n".join(line for line in body_lines if line is not None),
    })

    recipient = customer.email if customer and customer.email else ""
    return f"mailto:{recipient}?{params}"


def send_invoice_email(comp: Company | None, customer: Customer | None, invoice: Invoice) -> None:
    if not customer or not customer.email:
        ui.notify("Keine Email-Adresse beim Kunden hinterlegt", color="red")
        return
    mailto = build_invoice_mailto(comp, customer, invoice)
    ui.run_javascript(f"window.location.href = {json.dumps(mailto)}")


# -------------------------
# Revisions "Edit with risk"
# -------------------------

def _snapshot_invoice(session, invoice: Invoice) -> str:
    items = session.exec(select(InvoiceItem).where(InvoiceItem.invoice_id == invoice.id)).all()
    payload = {
        "invoice": {
            "id": invoice.id,
            "customer_id": invoice.customer_id,
            "nr": invoice.nr,
            "title": invoice.title,
            "date": invoice.date,
            "delivery_date": invoice.delivery_date,
            "recipient_name": invoice.recipient_name,
            "recipient_street": invoice.recipient_street,
            "recipient_postal_code": invoice.recipient_postal_code,
            "recipient_city": invoice.recipient_city,
            "total_brutto": invoice.total_brutto,
            "status": invoice.status.value if hasattr(invoice.status, "value") else str(invoice.status),
            "revision_nr": invoice.revision_nr,
            "updated_at": invoice.updated_at,
            "related_invoice_id": invoice.related_invoice_id,
            "pdf_filename": invoice.pdf_filename,
            "pdf_storage": invoice.pdf_storage,
        },
        "items": [
            {
                "id": it.id,
                "description": it.description,
                "quantity": it.quantity,
                "unit_price": it.unit_price,
            }
            for it in items
        ],
    }
    return json.dumps(payload)


def create_invoice_revision_and_edit(invoice_id: int, reason: str) -> int | None:
    with get_session() as s:
        original = s.get(Invoice, invoice_id)
        if not original:
            return None

        next_revision = int(original.revision_nr or 0) + 1
        snapshot_json = _snapshot_invoice(s, original)

        s.add(InvoiceRevision(
            invoice_id=original.id,
            revision_nr=next_revision,
            reason=reason,
            snapshot_json=snapshot_json,
            pdf_filename_previous=original.pdf_filename or "",
        ))

        original.revision_nr = next_revision
        original.updated_at = datetime.now().isoformat()
        s.add(original)

        new_inv = Invoice(
            customer_id=original.customer_id,
            nr=None,
            title=original.title,
            date=original.date,
            delivery_date=original.delivery_date,
            recipient_name=original.recipient_name,
            recipient_street=original.recipient_street,
            recipient_postal_code=original.recipient_postal_code,
            recipient_city=original.recipient_city,
            total_brutto=original.total_brutto,
            status=InvoiceStatus.DRAFT,
            related_invoice_id=original.id,
        )
        s.add(new_inv)
        s.commit()
        s.refresh(new_inv)

        old_items = s.exec(select(InvoiceItem).where(InvoiceItem.invoice_id == original.id)).all()
        for it in old_items:
            s.add(InvoiceItem(
                invoice_id=new_inv.id,
                description=it.description,
                quantity=it.quantity,
                unit_price=it.unit_price,
            ))

        log_audit_action(s, "INVOICE_RISK_EDIT", invoice_id=original.id)
        s.commit()

        return int(new_inv.id)


# -------------------------
# Dashboard
# -------------------------



# -------------------------
# Invoice Editor
# -------------------------



# -------------------------
# Invoice Detail
# -------------------------

def _status_step_current(invoice: Invoice) -> InvoiceStatus:
    s = invoice.status
    if s == InvoiceStatus.DRAFT:
        return InvoiceStatus.DRAFT
    if s in (InvoiceStatus.OPEN, InvoiceStatus.FINALIZED):
        return InvoiceStatus.OPEN
    if s == InvoiceStatus.SENT:
        return InvoiceStatus.SENT
    if s == InvoiceStatus.PAID:
        return InvoiceStatus.PAID
    if s == InvoiceStatus.CANCELLED:
        return InvoiceStatus.CANCELLED
    return InvoiceStatus.OPEN


def _render_status_stepper(invoice: Invoice) -> None:
    current = _status_step_current(invoice)
    steps = [
        (InvoiceStatus.DRAFT, "Entwurf"),
        (InvoiceStatus.OPEN, "Finalisiert"),
        (InvoiceStatus.SENT, "Gesendet"),
        (InvoiceStatus.PAID, "Bezahlt"),
        (InvoiceStatus.CANCELLED, "Storniert"),
    ]
    with ui.row().classes("items-center gap-2 flex-wrap"):
        for idx, (key, label) in enumerate(steps):
            is_active = key == current
            cls = "text-slate-900 font-semibold text-sm" if is_active else "text-slate-400 text-sm"
            ui.label(label).classes(cls)
            if idx < len(steps) - 1:
                ui.label("→").classes("text-slate-300 text-sm")




# -------------------------
# Invoices List (70/30)
# -------------------------



# -------------------------
# Customers
# -------------------------







# -------------------------
# Exports
# -------------------------



# -------------------------
# Settings
# -------------------------



# -------------------------
# Ledger (Finanzen)
# -------------------------



# -------------------------
# Expenses
# -------------------------
